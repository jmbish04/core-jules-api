<!-- 91984971-7725-44d7-a54c-75a92a8412b8 7608e59c-71a0-4e08-837d-fb4fdfd830e9 -->
# Multiâ€‘Protocol Jules Orchestrator Upgrade (No stubs)

## Scope

Transform this Worker into a complete agent wrapper around the Jules API using the existing `src/services/jules.ts` client. Expose REST, WebSocket (Durable Object), RPC, and MCP over a shared command registry. Implement Drizzle+Kysely D1 data model, Cloudflare Queues for orchestration and polling, GitHub repo bootstrap and PR lifeâ€‘cycle automation, Gemini review prompting and code comment extraction, MCPâ€‘driven validation of comments, rules enforcement, merge/cleanup, and dynamic OpenAPI 3.1.0 from Zod. All components are fully implemented with no mocks.

## Concrete Integrations

- Jules: `https://jules.googleapis.com/v1alpha`, header `X-Goog-Api-Key: env.JULES_API_KEY`, pagination via `nextPageToken`. We use the real `JulesSDK` in `src/services/jules.ts` for all calls.
- Client auth: require `env.WORKER_API_KEY` for `/api/*`, `/mcp/*`, `/rpc`, and `/ws` (via `?key=` or `Authorization: Bearer` or `x-api-key`). `/` and `/openapi.*` are public.
- GitHub: use `env.GITHUB_TOKEN` to create default repo (if none provided) under owner `jmbish04`, monitor PRs, post comments, add reactions, merge, and delete branches via GitHub REST API v3.
- Queues: use a dedicated Cloudflare Queue `AGENT_QUEUE` for background orchestration: Jules/PR polling, MCP validations, and health runs. The Worker is the consumer.
- Cron: daily schedule triggers `/api/health/run` path via internal task dispatch.
- WS: Durable Object provides a hibernatable room keyed by `projectId` for realâ€‘time progress.

## Data Model (Drizzle schema)

- `projects` (id TEXT pk uuid, repo_owner TEXT, repo_name TEXT, default_branch TEXT, visibility TEXT CHECK in ['public','private'], jules_source_name TEXT, created_at TEXT)
- `repos` (id TEXT pk uuid, owner TEXT, name TEXT, html_url TEXT, default_branch TEXT, visibility TEXT, created_at TEXT)
- `plans` (id TEXT pk uuid, project_id TEXT fk->projects.id, phase_index INTEGER, title TEXT, status TEXT CHECK in ['planned','active','completed','failed'], created_at TEXT)
- `epics` (id TEXT pk uuid, project_id TEXT fk, plan_id TEXT fk, title TEXT, index INTEGER, status TEXT CHECK in ['planned','active','completed','failed'])
- `tasks` (id TEXT pk uuid, epic_id TEXT fk->epics.id, title TEXT, status TEXT CHECK in ['pending','running','done','blocked'], created_at TEXT)
- `jules_sessions` (name TEXT pk, session_id TEXT, project_id TEXT fk, title TEXT, require_plan_approval INTEGER, automation_mode TEXT, state TEXT, url TEXT, create_time TEXT, update_time TEXT)
- `activities` (id TEXT pk, session_name TEXT fk->jules_sessions.name, originator TEXT, type TEXT, payload TEXT, create_time TEXT)
- `pr_records` (id TEXT pk uuid, project_id TEXT fk, session_name TEXT fk, repo_owner TEXT, repo_name TEXT, pr_number INTEGER, pr_url TEXT, head_branch TEXT, base_branch TEXT, is_draft INTEGER, state TEXT, created_at TEXT)
- `pr_code_comments` (id TEXT pk uuid, pr_record_id TEXT fk->pr_records.id, gemini_comment_id INTEGER, file_path TEXT, line_start INTEGER, line_end INTEGER, code_snippet TEXT, comment TEXT, extracted_at TEXT, mcp_findings TEXT, ai_instruction TEXT, status TEXT CHECK in ['pending','validated','posted','resolved'])
- `pr_actions` (id TEXT pk uuid, pr_record_id TEXT fk, action TEXT CHECK in ['prompt_gemini','post_fix_all','merge','delete_branch'], details TEXT, created_at TEXT)
- `worker_activity_logs` (id TEXT pk uuid, project_id TEXT fk, session_name TEXT fk, stage TEXT, message TEXT, meta TEXT, ts TEXT)
- `rule_defs` (id TEXT pk uuid, key TEXT UNIQUE, description TEXT, severity TEXT CHECK in ['info','warn','error'])
- `rule_checklist` (id TEXT pk uuid, project_id TEXT fk, rule_id TEXT fk->rule_defs.id, status TEXT CHECK in ['pending','passed','failed'], notes TEXT, checked_at TEXT)
- `test_defs` (id TEXT pk uuid, key TEXT UNIQUE, name TEXT, description TEXT, definition TEXT)
- `test_results` (id TEXT pk uuid, test_def_id TEXT fk->test_defs.id, session_name TEXT fk, status TEXT CHECK in ['pass','fail','error'], logs TEXT, ai_notes TEXT, created_at TEXT)
- `audit_logs` (id TEXT pk uuid, actor TEXT, action TEXT, target TEXT, details TEXT, ts TEXT)

All tables will have Drizzle indices where appropriate: e.g., `idx_jules_sessions_project`, `idx_pr_records_project_prnum`, `idx_comments_pr`, `idx_logs_project_time`.

## Queues

- Binding: `AGENT_QUEUE` (producer in code, consumer in this Worker).
- Message shapes:
- `{ type: 'poll-jules', projectId: string, sessionName: string }`
- `{ type: 'poll-github-pr', projectId: string, repoOwner: string, repoName: string, prNumber: number }`
- `{ type: 'mcp-validate-comment', commentId: string }`
- `{ type: 'health-run', sessionId?: string }`

## WebSocket Events (Durable Object Room)

- `project.update`: `{ projectId, phase, status }`
- `jules.activity`: `{ sessionName, activity }`
- `pr.update`: `{ repoOwner, repoName, prNumber, state, isDraft }`
- `rules.update`: `{ projectId, ruleKey, status }`
- `health.update`: `{ sessionName?, status, results? }`

## REST/API Surface (Hono)

- `GET /` â†’ health (service version, ts)
- `GET /openapi.json` â†’ runtime generated (Zod registry)
- `GET /openapi.yaml` â†’ runtime generated (YAML)
- `GET /ws?projectId=...&key=...` â†’ WS upgrade via DO
- `POST /rpc` â†’ JSON-RPC harness
- `POST /api/new/app` â†’ createNewApp
- `POST /api/new/feature` â†’ createNewFeature
- `POST /api/bug` â†’ reportBug
- `POST /api/flow/:flowKey` â†’ runFlowByKey
- `ALL /api/raw/*` â†’ proxyRawJules (path maps after `/api/raw` to Jules base)
- `POST /api/health/run` â†’ runHealth

CORS only on `/api/*`. Auth middleware on `/api/*`, `/mcp/*`, `/rpc`, and `/ws`.

## OpenAPI 3.1.0 (zod-to-openapi)

- jsonSchemaDialect: 2020-12.
- Tags: Jules, Intake, Flows, Raw, Health, PR, Rules.
- OperationIds (unique): createNewApp, createNewFeature, reportBug, runFlowByKey, proxyRawJules, runHealth, rpcDispatch, listOpenApiJson, listOpenApiYaml, connectWs.
- All request/response/error schemas defined in `src/schemas/apiSchemas.ts` and registered in `src/utils/openapi.ts`.

## Zod Schemas (examples)

- `NewAppRequest`: { title, prompt, frontendPreset?, infraPreset?, requirePlanApproval?, automationMode?, github?: { owner?, name?, visibility? } }
- `NewFeatureRequest`: { repoOwner, repoName, prompt, branch?: 'main' | string }
- `BugReportRequest`: { repoOwner, repoName, error, prompt?, branch?: string }
- `FlowRunRequest`: { flowKey, params?: Record<string, unknown> }
- `RawProxyRequest`: transparently forward method/body/query; path automatically maps; returns raw Jules JSON with status.
- `HealthRunRequest`: { tests?: string[] }
- `ErrorResponse`: { success: false, error: string, details?: unknown }
- Plus shared `Task`, `Plan`, `RuleCheck`, `TestResult` entities for responses.

## RPC Registry (shared across REST/WS/RPC/MCP)

- Intake: `newApp`, `newFeature`, `fileBug`
- Jules ops: `approvePlan`, `sendMessage`, `listSources`, `listSessions`, `listActivities`
- PR pipeline: `pollGithubPr`, `triggerGeminiReview`, `extractPrComments`, `validateCommentsWithMcp`, `postFixAllComments`, `verifyPatchMergeAndCleanup`, `advanceNextPhase`
- Flows: `runFlow`
- Health: `healthRun`
- Raw: `rawProxy`

Each method validates input with Zod, writes D1 records via Drizzle, and may enqueue messages to `AGENT_QUEUE`.

## GitHub Logic (no stubs)

- Ensure repo: if no source, create repo under `jmbish04` via `POST /orgs/{org}/repos` (or `user/repos` if needed); name: slugified title; default branch `main`; visibility from request or default `public`.
- Monitor PR: `GET /repos/{owner}/{repo}/pulls?state=open&head={owner}:*` to detect PR; then `GET /repos/{owner}/{repo}/pulls/{pr_number}` periodically.
- Prompt Gemini: if no Gemini comments after 2â€“3 polls, convert from draft if `draft=true` via `PATCH /repos/{owner}/{repo}/pulls/{pr_number}`, then `POST /repos/{owner}/{repo}/issues/{pr_number}/comments` with body `/gemini review`.
- Extract comments: fetch both `GET issues/{pr}/comments` and `GET pulls/{pr}/comments`; filter out owner/bot noise; parse code blocks and inline review comments; extract `file`, `line`, code snippet (if provided), and text; upsert into `pr_code_comments`.
- Validate comments: for each comment, enqueue `mcp-validate-comment` job. Worker fetches candidate docs pages:
- Cloudflare Workers/Page docs: build URLs from keyword heuristics (e.g., `https://developers.cloudflare.com/workers/` + slug detection) and fetch HTML; store top `<h1>/<h2>` text and relevant sections in `mcp_findings` as JSON. If `env.AI` binding is configured, summarize findings; otherwise store raw excerpts (still real, no stubs).
- shadcn/ui: fetch component docs from `https://ui.shadcn.com` paths similarly.
Store synthesized `ai_instruction` derived from extracted sections (ruleâ€‘based template) for deterministic guidance.
- Post fix-all: aggregate comments grouped by `file_path`, ascending by `line_start`; build a single PRâ€‘level comment tagging `@jules` and embedding the grouped items (file, ranges, snippet, Gemini comment, AI instruction); save `comment id/url`.
- Track Jules pickup: add ðŸ‘€ reaction to own comment and check `GET /repos/.../issues/comments/{comment_id}/reactions` to detect reciprocal reaction; also poll Jules activities via SDK to confirm start.
- Verify patch: after Jules reports completion, use `GET /repos/.../pulls/{pr}/files` to verify changed files/ranges; if not verifiable after 2â€“3 polls, add `worker_activity_logs` entry and flag HIL.
- Merge and cleanup: `PUT /repos/.../pulls/{pr}/merge` with `merge_method=squash`; then `DELETE /repos/{owner}/{repo}/git/refs/heads/{head_branch}`; record in `pr_actions`.

## Rules Enforcement (no stubs)

- Seed `rule_defs` (on first run) with keys:
- `pkg.scripts.migrations`: package.json must include `migrate:remote`, `migrate:local`, `deploy`
- `wrangler.latest`: wrangler pinned to latest (`^${currentMajor}`)
- `openapi.paths`: `/openapi.json` and `/openapi.yaml` exist
- `crons.health`: daily cron present
- `do.room`: Durable Object binding `RoomDO`
- Implement validators in code (no eval): for each rule, run concrete checks (read package.json from repo via GitHub API and parse; read `wrangler.jsonc` via contents API and parse JSONC using a tolerant parser; verify cron and DO bindings). Store status in `rule_checklist` and notes.

## Health Tests (no stubs)

- `test_defs` seeded with basic tests:
- `http.ok`: `GET /` returns 200
- `openapi.ok`: `GET /openapi.json` returns 200 and `openapi` = `3.1.0`
- `ws.upgrade`: `GET /ws` with Upgrade=websocket yields 101 via DO
- `POST /api/health/run` executes defined tests, stores `test_results` with logs and interprets results (string parsing). Cron triggers a queue message `{type:'health-run'}` daily.

## MCP Endpoints (no stubs)

- `GET /mcp/tools`: returns tools derived from `rpcRegistry` with zod shapes
- `POST /mcp/execute`: `{ tool, params }` validated and dispatched through the same registry

## Security

- Middleware validates API key for protected paths; WS checks query/header. Responses include standard security headers (frameguard deny, no sniff, referrerâ€‘policy, contentâ€‘securityâ€‘policy minimal), and CORS only on `/api/*`.

## Files to Implement/Update

- `src/types.ts`: Env interface (DB, ROOM_DO, WORKER_API_KEY, JULES_API_KEY, GITHUB_TOKEN, AGENT_QUEUE?) and `RPCMethod` union.
- `src/db/schema.ts`: Drizzle schema per the tables above.
- `src/db/client.ts`: Drizzle + Kysely (D1Dialect) init, export `initDb` and shared types.
- `src/schemas/apiSchemas.ts`: Zod entities/requests/responses/errors with `.openapi` metadata.
- `src/utils/openapi.ts`: OpenAPI registry + generator with operationIds, tags, servers.
- `src/utils/ws.ts`: broadcast helpers and JSON framing.
- `src/utils/auth.ts`: API/WS auth middleware.
- `src/utils/github.ts`: concrete GitHub REST helpers (using fetch, proper Accept headers).
- `src/do/RoomDO.ts`: hibernation WS using `this.ctx.acceptWebSocket` and handlers.
- `src/rpc.ts`: full registry + dispatcher; enqueues to `AGENT_QUEUE` where needed.
- `src/mcp.ts`: tools listing + execute mapping to registry with Zod validation.
- `src/router.ts`: Hono router with routes and error envelope `{ success: false, error, details? }`.
- `src/index.ts`: main dispatch (openapi, ws, mcp, rest/rpc) + security headers.
- `wrangler.jsonc`: ensure DO binding, D1 DB (already present), add `queues.producers` and `queues.consumers`, and `triggers.crons` daily schedule.
- `drizzle.config.ts`: point to `drizzle/migrations` + D1 connection; scripts to generate/apply.
- `tests/examples.md`: curl, WS, RPC samples, including raw proxy and pagination.
- `package.json`: scripts: `migrate:remote`, `migrate:local`, `deploy`; deps: `hono`, `zod`, `@asteasolutions/zod-to-openapi`, `yaml`, `drizzle-orm`, `drizzle-kit`, `kysely`, `kysely-d1`.

## Defaults (can be overridden in requests)

- GitHub repo owner: `jmbish04`; visibility: `public`; merge method: `squash`.
- Polling cadence: every 60s for Jules and PR; Gemini trigger after 3 polls with no comments.
- WS projectId: provided by client; else `default`.

## Acceptance

- Endpoints are functional without stubs and produce real effects on Jules and GitHub.
- OpenAPI 3.1.0 generated dynamically reflects all routes and error shapes, with unique operationIds.
- Queues process orchestration reliably; cron triggers health runs recorded in D1.
- Rule checks must pass before merge; results visible in D1 and WS events.

### To-dos

- [ ] Add src/types.ts with Env (DB, ROOM_DO, WORKER_API_KEY, JULES_API_KEY)
- [ ] Create Drizzle schema for projects/plans/tasks/rules/tests tables
- [ ] Implement src/db/client.ts initializing Drizzle and Kysely
- [ ] Define Zod request/response schemas for new endpoints
- [ ] Implement src/rpc.ts with methods (newApp, newFeature, bug, flow, raw, health)
- [ ] Update src/router.ts with REST routes, CORS, auth middleware
- [ ] Implement src/mcp.ts tools and execute mapping to rpcRegistry
- [ ] Implement src/do/RoomDO.ts with hibernation WS and broadcast helpers
- [ ] Enhance src/utils/openapi.ts with paths and unique operationIds
- [ ] Add daily cron in wrangler.jsonc for health tests
- [ ] Add package.json scripts for migrate:remote/local and deploy; pin wrangler@latest
- [ ] Update tests/examples.md with curl, WS, RPC, MCP samples